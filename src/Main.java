public class Main {
    public static void main(String[] args) {
        //Урок с Ильёй Сазоновым.
        //Цикл do-while
        int userWantsToСontinue = 1;
        int level = 1;
        do {
            System.out.println("Завершен уровень " + level);
            System.out.println("Хотите продолжить?");
            level++;
        }
        while (userWantsToСontinue == 1 && level < 5);
        System.out.println("====================================================================================");
        //Цикл do-while
        int userWantsToСontinueX = 1;
        // Переменная, обозначающая, что юзер хочет продолжить игру
        // 1 — хочет продолжить, 0 — не хочет продолжать играть
        int levelX = 1;
        // Переменная со значением номера уровня
        do {
            System.out.println("Завершен уровень " + levelX);
            // Выводим текст с номером уровня игры
            System.out.println("Хотите продолжить?");
            // Спрашиваем, хочет ли пользователь продолжить игру
            levelX++;
            // К переменной level прибавляем 1, это следующий уровень
        }
        while (userWantsToСontinueX == 1 && levelX < 5);
        // Записываем условие: если пользователь хочет продолжить
        // и номер уровня меньше или равен 5
        System.out.println("=======================================================================================");
        //С условным оператором придется написать большое количество одинаковых проверок:
        int isQueueEmpty = 1;
        if (isQueueEmpty == 1) {
            System.out.println("Пожалуйста подождите!Сейчас Вас пригласят в кабинет!");
        }
        if (isQueueEmpty == 1) {
            System.out.println("Пожалуйста подождите!Сейчас Вас пригласят в кабинет!");
        }
        if (isQueueEmpty == 1) {
            System.out.println("Пожалуйста подождите!Сейчас Вас пригласят в кабинет!");
        }
        System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");

        //Задача про очередь решается с помощью цикла while так:
        int isQueueEmptyX = 1;
        while (isQueueEmptyX == 1) {
            System.out.println("Пожалуйста подождите!Сейчас Вас пригласят в кабинет!");
            //System.out.println("Нажмите кнопку вызова сотрудника!");
            break;
        }
        System.out.println("==========================================================================================");
        //Как записать блок условия для цикла while
        //Указать true явно: while (true). См. пример в разделе «Оператор break».
        //Передать переменную: while (isQueueEmpty).
        //Указать логическое выражение, результатом которого будет true/false:
        int yourSalary = 0;
        while (yourSalary < 1_000_000) {
            System.out.println("Надо усердно работать!");
            break;
        }
        System.out.println("===================================================================================");
        int trueX = 1;
        while (trueX == 1) {
            System.out.println("Пожалуйста,подождите!");
            break;
        }
        System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
        int isQueueEmptyZOV = 1;
        if (isQueueEmptyZOV == 1) {
            System.out.println("Вы следующий, проходите!");
        }
        System.out.println("=======================================================================================");
        //Доработаем наш пример с электронной очередью с учетом того, что нам надоест ждать.
        int isQueueEmptyDog = 1;
        int dontWantToWait = 0;
        while (isQueueEmptyDog == 0) {
            System.out.println("Пожалуйста,подождите!");
            break;
        }
        while (isQueueEmptyDog == 1) { // Пока очередь перед нами не пуста
            if (dontWantToWait == 0) { // Если ждать надоело
                System.out.println("Вы уже уходите.Всего доброго!Мы надеемся увидеть Вас в будущем!");
                break; // Прерываем ожидание и уходим
            }
            System.out.println("Пожалуйста,подождите!");
            break;
        }
        System.out.println("==================================================================================");
        // Цикл do-while
        //По принципу работы цикл do-while похож на while. Отличие в том, что while может выполниться 0 раз
        // (если условие изначально равняется false), а цикл do-while выполнится минимум 1 раз.
        //Цикл while сначала проверяет условие в скобках и затем выполняет блок.
        // do-while сначала запускает блок, а потом проверяет условие.
        //Опишем работу цикла do-while простым языком:
        //ВЫПОЛНЯЙ { этот блок } ПОКА (условие соблюдается)
        int quantity = 0;
        do {
            quantity = quantity + 1;
            System.out.println("Количество:" + quantity);
        } while (quantity < 10);
        System.out.println("==================================================================================");
        int i = 5;
        while (i < 9) {
            System.out.println(i);
            i++;
        }
        System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
        int ix = 5;
        do {
            System.out.println(ix);
            ix++;
        } while (ix < 9);
        System.out.println("==================================================================================");
        //Решаем задачи с помощью цикла do-while
        //Рассмотрим пример, для решения которого пригодится цикл do-while.
        //Представим, что мы разрабатываем игру. Если пользователь завершает первый уровень, программа у него
        // спрашивает, хочет ли он продолжить. Если ответ «да», то запускается следующий уровень. И так до
        // пятого уровня.
        //Запишем алгоритм с помощью цикла do-while.
        //Объявим переменную с информацией о том, что пользователь хочет продолжить игру. Для удобства вместо
        // логической переменной используем переменную int, значение которой 1 — это true:
        //int userWantsToСontinue = 1;
        //И объявим переменную с начальным уровнем:
        //int level = 1;
        //Запишем, что нужно сделать до проверки условия:
        //do {
        //System.out.println("Завершен уровень " + level);
        // Выводим текст с номером уровня игры
        //System.out.println("Хотите продолжить?");
        // Спрашиваем, хочет ли пользователь продолжить игру
        //level++;
        // К переменной level прибавляем 1, это следующий уровень

        //Теперь нужно указать условие — если пользователь хочет продолжить игру и если номер уровня меньше
        //или равен 5:
        //while (userWantsToСontinue == 1 && level < 5);
        //Полностью код будет выглядеть так:
        int userWantsToСontinueC = 1;
        int levelC = 1;
        do {
            System.out.println("Завершен уровень " + levelC);
            System.out.println("Хотите продолжить?");
            levelC++;
        } while (userWantsToСontinueC == 1 && levelC < 5);
        //Как мы видим, даже если пользователь не захочет дальше играть, мы как минимум 1 раз запустим игру.
        System.out.println("======================================================================================");
        //Оператор continue.(Грязный пример,для понимания темы!)
        //Бывают ситуации, когда нам нужно принудительно пропустить выполнение шага цикла в зависимости от
        // условий.
        //Например, наше ожидание в очереди скрасит поход по делам. В поликлинике мы можем, пока ждем очередь
        // к одному врачу, посетить другого врача. В МФЦ выпить кофе из кофейного аппарата.
        //Представим, что наличие такого рода «развлечений» во время ожидания описано в виде boolean переменной
        // needToDoSomethingElse.
        //Код будет выглядеть следующим образом:
        int isQueueEmptyNow = 1;
        int needToDoSomethingElse = 0;
        while (isQueueEmptyNow == 1) {
            System.out.println("Ждём приглашения в кабинет!");
            if (needToDoSomethingElse == 1) {
                System.out.println("Можно выпить чашечку кофе!");
                break;
            }
            break;
        }
        System.out.println("===================================================================================");
        //Оператор continue.
        //Ниже приведён очень хороший пример использования оператора "continue" в цикле for:
        // Объявляем переменную dayNumber, она равна номеру дня в месяце
        for (int dayNumber = 1; dayNumber <= 31; dayNumber++) {
            // Каждый день проверяем, является ли он третьим (выходным)
            if (dayNumber % 3 == 0) {
                // Выводим сообщение
                System.out.println("Сегодня " + dayNumber + "-е " + "число.Сегодня отдыхаем!");
                // Ждем следующий день
                continue;
            }
            System.out.println("Сегодня " + dayNumber + "-е " + "число.Сегодня рабочий день!");
            // Если день не выходной, выводим сообщение
        }
        System.out.println("==================================================================================");
        //Использование оператора "continue;" в цикле while:
        int day = 0;
        while (day < 31) {
            day++;
            if (day % 3 == 0) {
                System.out.println("Сегодня " + day + "-е " + "число.Сегодня отдыхаем!");
                continue;
            }
            System.out.println("Сегодня " + day + "-е " + "число.Сегодня рабочий день!");
        }
        System.out.println("======================================================================================");
        // for или while?
        //Циклы for и while занимаются одним и тем же и «под капотом» превращаются в одни и те же инструкции.
        // Вопрос выбора между for и while — вопрос удобства.
        //Если переменная со счетчиком в цикле нужна и она меняется строго в конце итерации, удобнее for.
        //Если переменная со счетчиком цикла не нужна или она может измениться в любой момент, то разработчики
        // предпочитают while.

//<<<<<<< testMemoryCribScribe
        // public static void main(String[] args) {
        //ПЕРЕМЕННЫЕ В JAVA.
////////////////////////////////////////////////////////////////////////////////////////
        //Целочисленные переменные.
        //=========================
        //1// byte
        // -----
        //от -128 до 127 (объём памяти 1 байт)

        //2// short
        //-----
        //от -32768 до 32767 (2 байта)

        //3// int
        //---
        //-2147483648 до 2147483647 (4 байта)

        //4// long
        //----
        //-9223372036854775808 до 9223372036854775807 (8 байт)

        //С плавающей точкой.
        //===================
        //5// float
        //-----
        //от -3.4+38 до 3.4E+38 (4 байта),
        //а правильно будет -3.4E38 до 3.4Е38 (!правильная запись в шестнацатиричной системе(4 байт))
        //от -3.3055419921875  до 3.3055419921875 (4 байт)

        //6// double
        //------
        //от -1.7E+308 до 1.7E+308 (8 байт),
        //а правильно будет -1.7E308 до 1.7E308 (!правильная запись в шестнадцатиричной системе(8 байт))
        //oт  -1.49292755126953 до 1.49292755126953 (8байт)

        //Символы.
        //========
        //7// сhar
        //----
        //Переменные типа char - все символы на планете Земля(иероглифы,буквы,математические и иные знаки и т.п. и т.д.)
        //от 0 до 65536 (2 байта)

        //Логические.
        //===========
        //8// boolean
        // -------
        //Может содержать либо true либо false
        //(1бит информации: либо 1(заряженная конденсаторная ячейка),либо 0(разряженная конденсаторная ячейка))

        //Справка
        //+++++++
        //1 байт = 8 бит
        //Ячейка памяти для переменной типа boolean имеет размер 1bit,а ячейки памяти переменных типа
        ///byte,short,int,long,float,double,char.
        //Команда String.format("%.2f",total)//смотрим ниже// позволяет округлить дробное значение,
        //увеличив,тем самым размер целочисленной части дроби.

        //double salary = 65535;
        //double total = 0;
        //for ( int i = 1 ; i <= 12 ; i = i + 1) {
        //total = total + total/100;
        //total = total + salary;
        //String result = String.format("%.2f",total);
        //System.out.println("Зарплата программиста за месяц " + i + " " + "к выплате " +  result + " " +
        //"рублей.");}

        //Вывод:Чаще всего мы будем работать с переменными типа int,double.
        //Переменную типа boolean будем использовать реже,переменную типа
        //boolean можно заменить перменной типа int,присвоив ей значение 1 или 0.
        //Переменную типа boolean используем,только тогда,когда наши коллеги
        //вместо значения 1 или 0 пытаются записать(по запарке) другие значения.
        //Поэтому переменную boolean желательно использовать во избежание недоразумений.

        System.out.println("================================================================================");
        System.out.println("================================================================================");
        System.out.println("================================================================================");
        System.out.println("================================================================================");
        System.out.println("================================================================================");
        System.out.println("================================================================================");
        char c = '+';
        char d = '/';
        char e = '*';
        char f = '-';
        System.out.println(c + " != " + d + " != " + e + " != " + f);
        char red = 'r';
        char yellow = 'y';
        char green = 'g';
        if (red == 'r') {
            System.out.println("Красный! Ехать нельзя!");
        } else {
            if (yellow == 'y') {
                System.out.println("Желтый. Внимание.");
            } else {
                if (green == 'g') {
                    System.out.println("Зеленый! Проезд разрешен.");
                }
            }
        }
        //Или можно тот же код можно переписать:
        char redX = 'a';
        char yellowX = 'b';
        char greenX = 'g';
        if (redX == 'r') {
            System.out.println("Красный! Ехать нельзя!");
        } else {
            if (yellowX == 'y') {
                System.out.println("Желтый. Внимание.");
            } else {
                System.out.println("Зеленый! Проезд разрешен.");
            }

        }
        //Оба кода работают!Но каждый по своему алгоритму.
        System.out.println("/////////////////////////////////////////////////////////////////////////////////");
        //Конструкция switch:
        int dayOfWeekNumber = 3;

        switch (dayOfWeekNumber) {
            case 1:
                System.out.println("Понедельник");
                break;
            case 2:
                System.out.println("Вторник");
                break;
            case 3:
                System.out.println("Среда");
                break;
            case 4:
                System.out.println("Четверг");
                break;
            case 5:
                System.out.println("Пятница");
                break;
            case 6:
                System.out.println("Суббота");
                break;
            case 7:
                System.out.println("Воскресенье");
                break;
            default:
                System.out.println("Такого дня не существует");
        }
        System.out.println("///////////////////////////////////////////////////////////////////////////////////");
        int dayOfWeekNumberX = 3;

        switch (dayOfWeekNumberX) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                System.out.println("Будний день");
                break;
            case 6:
            case 7:
                System.out.println("Выходной день");
                break;
            default:
                System.out.println("Такого дня не существует");
        }
        System.out.println("///////////////////////////////////////////////////////////////////////////////");
        //Нужно знать
        //Код группируется в фигурные скобки {}.
        //Участок кода, сгруппированный в такие скобки, называется блоком кода.
        //Все переменные, объявленные внутри блока, не видны за его пределами.
        //Это называется областью видимости переменных.
        //Конструкции if-else if-else достаточно гибкие и позволяют строить условные конструкции разными способами.
        //Правила следующие.
        //Блок if должен быть обязательно.
        //Блок else if не является обязательным, но может быть представлен в любом количестве при разных
        // условиях, которые записаны в круглых скобках, но крайне не рекомендуется использовать больше
        // одного. В такой ситуации, если весь диапазон значений известен заранее, лучше использовать switch.
        //Блок else не обязателен, но если присутствует, то только в единственном экземпляре.
        //Выражения в блоке условий могут быть представлены в виде нескольких сравнений одновременно.
        //Для этого используются логические операторы И (&&) и ИЛИ (||).
        //Работают они следующим образом.
        //Допустим, нам нужно определить, является погода комфортной или нет. За комфортную погоду берем температуру воздуха больше или равно 20 И температуру меньше или равно 25, т. е. от 20 до 25. Если наше значение попадает в этот диапазон, вывести сообщение о том, что погода комфортна для прогулок, иначе вывести предупреждение.

        int temperature = 21;
        if (temperature >= 20 && temperature <= 25) {
            System.out.println("Погода комфортна для прогулок");
        } else {
            System.out.println("Стоит повременить с прогулкой");
        }
        //Читаем как:
        //"ЕСЛИ температура больше или равна 20 И температура меньше или равна 25, ТО вывести сообщение о
        // комфортных условиях,
        //ИНАЧЕ вывести сообщение с предупреждением".
        //В этом коде имеются два условия, которые скомбинированы через оператор И.
        //Если хотя бы одно из двух вернет false, выражение не будет выполнено.
        //Оператор И (&&) подразумевает, что оба условия должны быть true.
        //Развернем условие задачи. Теперь нам нужно вывести предупреждение, если температура ниже 20 ИЛИ температура выше 25.

        int temperatureX = 19;
        if (temperatureX < 20 || temperatureX > 25) {
            System.out.println("Стоит повременить с прогулкой");
        }
        //Читаем как:
        //"ЕСЛИ температура меньше 20 ИЛИ температура больше 25,
        //ТО вывести предупреждение".
        //В этом коде имеются два условия, которые скомбинированы через оператор ИЛИ.
        //Если хотя бы одно из двух будет true, блок выполнится и в консоль будет выведено сообщение с предупреждением.
        //Интересный факт
        //Логические операторы И (&&) и ИЛИ (||) оптимизированы и не будут осуществлять вычисление второго
        // условия, если его результат не повлияет на общий результат. Например:
        //И (&&)
        // true && true будет равно true, выполняются оба сравнения.
        //true && false будет равно false, выполнятся оба сравнения.
        //false && true будет равно false, выполняется первое сравнение, получаем false, второе высчитывать
        // не имеет смысла, оно не повлияет на результат.
        //false && false также будет равно false, выполнение второго сравнения не имеет смысла.
        //ИЛИ (||)
        //true || true будет равно true, вычислять второе сравнение не имеет смысла, так как первое уже
        // позволяет получить общий результат true.
        //true || false будет равно true, вычислять второе сравнение не имеет смысла.
        //false || true будет равно true, выполняются оба сравнения, так как второе напрямую влияет на
        // результат.
        //false || false будет равно false, выполняются оба сравнения, так как второе может повлиять на
        // результат (но не влияет).
        System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
        System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
        System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
        System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
        System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
        //Итак,Нужно знать!!!!!
        //1.Код группируется в фигурные скобки {}.Содержимое скобок{} - блок код - область видимости переменных.
        //2.Конструкции if-else if-else достаточно гибкие и позволяют строить условные конструкции разными
        // способами.
        //Правила следующие.
        //Блок if должен быть обязательно.
        //Блок else if не является обязательным, но может быть представлен в любом количестве при разных
        // условиях, которые записаны в круглых скобках, но крайне не рекомендуется использовать больше одного.
        // В такой ситуации, если весь диапазон значений известен заранее, лучше использовать switch.
        //Блок else не обязателен, но если присутствует, то только в единственном экземпляре.
        //3.Выражения в блоке условий могут быть представлены в виде нескольких сравнений одновременно.
        //Для этого используются логические операторы И (&&) и ИЛИ (||).
        //4.И (&&)
        //true && true будет равно true, выполняются оба сравнения.
        //true && false будет равно false, выполнятся оба сравнения.
        //false && true будет равно false, выполняется первое сравнение, получаем false, второе высчитывать не
        // имеет смысла, оно не повлияет на результат.
        //false && false также будет равно false, выполнение второго сравнения не имеет смысла.
        //При использовании двойного имперсанта "&&" доминирует false!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        //5.ИЛИ (||)
        //true || true будет равно true, вычислять второе сравнение не имеет смысла, так как первое уже
        // позволяет получить общий результат true.
        //true || false будет равно true, вычислять второе сравнение не имеет смысла.
        //false || true будет равно true, выполняются оба сравнения, так как второе напрямую влияет на
        // результат.
        //false || false будет равно false, выполняются оба сравнения, так как второе может повлиять на
        // результат (но не влияет).
        //При использовании в конструкции или "||" доминирует true!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        System.out.println("Hello Russia!Hello China!Hello world!");
    }
}
